{% extends "dashboard.html" %}

{% block title %}Dashboard Ventas{% endblock %}

{% block extra_head %}
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
{% endblock %}

{% block filtros_left %}
  <a href="{% url 'ventas_venta_list' %}" class="btn-filter btn-view">Vista</a>
{% endblock %}

{% block filtros %}
  <div class="ventas-filter-center">
    <form action="{% url 'ventas_venta_dashboard' %}" method="get" class="filter-form-simple dispersiones-filter">
      <div class="filter-stack">
        <label for="fecha_desde">Desde</label>
        <input type="date" id="fecha_desde" name="fecha_desde" value="{{ fecha_desde }}">
      </div>

      <div class="filter-stack">
        <label for="fecha_hasta">Hasta</label>
        <input type="date" id="fecha_hasta" name="fecha_hasta" value="{{ fecha_hasta }}">
      </div>

      <button type="submit" class="btn-filter">Filtrar</button>
      <a href="{% url 'ventas_venta_dashboard' %}" class="btn-filter">Limpiar</a>
    </form>
  </div>
{% endblock %}

{% block filtros_right %}
  <a class="btn-primary btn-primary-inline" target="_blank" href="{% url 'ventas_venta_dashboard_resumen' %}{% if request.GET %}?{{ request.GET.urlencode }}{% endif %}">Resumen</a>
{% endblock %}

{% block dashboard_content %}
  {% if ventas_count == 0 %}
    <div class="dashboard-empty">Sin ventas en el periodo.</div>
  {% else %}
    <div class="dashboard-total">Total ventas: {{ total_ventas_display }}</div>
    <div class="dashboard-grid">
      <div class="dashboard-card">
        <div class="dashboard-title">Ventas por servicio</div>
        <canvas id="ventasPorServicio" class="dashboard-canvas" aria-label="Ventas por servicio"></canvas>
      </div>
      <div class="dashboard-card">
        <div class="dashboard-title">Total pagado vs pendiente</div>
        <canvas id="ventasPorEstatus" class="dashboard-canvas" aria-label="Ventas por estatus"></canvas>
      </div>
    </div>
  {% endif %}

  {{ chart_data|json_script:"ventas-dashboard-data" }}

  <script>
    (function () {
      const raw = document.getElementById("ventas-dashboard-data");
      if (!raw) return;
      const data = JSON.parse(raw.textContent || "{}");
      if (!data || !data.labels_servicio || data.labels_servicio.length === 0) return;

      const baseBlue = "#2b313f";
      const labelColor = baseBlue;
      const money = new Intl.NumberFormat("es-MX", {
        style: "currency",
        currency: "MXN",
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      });
      const palette = ["#0a7a4d", "#f3b0b0"];
      const toRgb = (color) => {
        if (!color) return { r: 0, g: 0, b: 0 };
        if (color.startsWith("rgb")) {
          const nums = color.replace(/rgba?\\(|\\)|\\s/g, "").split(",").map(Number);
          return { r: nums[0] || 0, g: nums[1] || 0, b: nums[2] || 0 };
        }
        const clean = color.replace("#", "");
        const num = parseInt(clean, 16);
        return {
          r: (num >> 16) & 255,
          g: (num >> 8) & 255,
          b: num & 255
        };
      };
      const luminance = (rgb) => (0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b) / 255;
      const pickTextColor = (bg) => (luminance(toRgb(bg)) < 0.55 ? "#ffffff" : labelColor);

      const commonOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              label: (ctx) => ` ${money.format(ctx.parsed.y ?? ctx.parsed)}`
            }
          }
        },
        layout: {
          padding: { top: 24 }
        },
        scales: {
          x: {
            ticks: {
              color: labelColor,
              font: { weight: "600" }
            }
          },
          y: {
            grace: "10%",
            ticks: {
              color: labelColor,
              font: { weight: "600" },
              callback: (value) => money.format(value)
            }
          }
        }
      };

      const fixedLabels = {
        id: "fixedLabels",
        afterDatasetsDraw(chart) {
          const ctx = chart.ctx;
          const type = chart.config.type;
          const dataset = chart.data.datasets[0] || {};
          const dataArr = dataset.data || [];
          if (!dataArr.length) return;

          ctx.save();
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = "600 12px Arial";

          if (type === "doughnut") {
            const total = dataArr.reduce((sum, value) => sum + Number(value || 0), 0);
            const meta = chart.getDatasetMeta(0);
            const bgColors = dataset.backgroundColor || [];
            const chartArea = chart.chartArea;
            const items = [];

            meta.data.forEach((arc, i) => {
              const value = Number(dataArr[i] || 0);
              if (!value) return;
              const pct = total > 0 ? (value / total) * 100 : 0;
              const angle = (arc.startAngle + arc.endAngle) / 2;
              const side = Math.cos(angle) >= 0 ? 1 : -1;
              const anchor = {
                x: arc.x + Math.cos(angle) * arc.outerRadius,
                y: arc.y + Math.sin(angle) * arc.outerRadius
              };
              const y = arc.y + Math.sin(angle) * (arc.outerRadius + 18);
              items.push({
                side,
                anchor,
                y,
                label: chart.data.labels[i] || "",
                line2: `${money.format(value)} (${pct.toFixed(1)}%)`
              });
            });

            const minGap = 34;
            const left = items.filter(i => i.side < 0).sort((a, b) => a.y - b.y);
            const right = items.filter(i => i.side > 0).sort((a, b) => a.y - b.y);

            const adjust = (arr) => {
              let prev = null;
              const top = chartArea.top + 28;
              const bottom = chartArea.bottom - 28;
              arr.forEach((it) => {
                let y = Math.max(it.y, top);
                if (prev !== null && y - prev < minGap) y = prev + minGap;
                if (y > bottom) y = bottom;
                it.y = y;
                prev = y;
              });
            };
            adjust(left);
            adjust(right);

            ctx.save();
            ctx.beginPath();
            const clipPad = 10;
            ctx.rect(
              chartArea.left - clipPad,
              chartArea.top - clipPad,
              (chartArea.right - chartArea.left) + (clipPad * 2),
              (chartArea.bottom - chartArea.top) + (clipPad * 2)
            );
            ctx.clip();
            const lineColor = "#59b9c7";
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = 1;

            const drawSide = (arr, side) => {
              const textAlign = side > 0 ? "right" : "left";
              const textX = side > 0 ? (chartArea.right - 10) : (chartArea.left + 10);
              const textGap = 8;
              arr.forEach((it) => {
                const midX = Math.max(chartArea.left + 2, Math.min(it.anchor.x + side * 16, chartArea.right - 2));
                const endX = Math.max(chartArea.left + 10, Math.min(textX, chartArea.right - 10));
                ctx.beginPath();
                ctx.moveTo(it.anchor.x, it.anchor.y);
                ctx.lineTo(midX, it.y);
                const lineEndX = endX + (side > 0 ? -textGap : textGap);
                ctx.lineTo(lineEndX, it.y);
                ctx.stroke();

                ctx.textAlign = textAlign;
                ctx.fillStyle = labelColor;
                ctx.font = "600 11px Arial";
                const maxTextWidth = (chartArea.right - chartArea.left) * 0.35;
                const label = ctx.measureText(it.label).width > maxTextWidth ? `${it.label.slice(0, 12)}…` : it.label;
                const textXAdj = endX + (side > 0 ? -2 : 2);
                ctx.fillText(label, textXAdj, it.y - 8);
                ctx.font = "500 10px Arial";
                const line2 = ctx.measureText(it.line2).width > maxTextWidth ? `${it.line2.slice(0, 12)}…` : it.line2;
                ctx.fillText(line2, textXAdj, it.y + 8);
              });
            };

            drawSide(left, -1);
            drawSide(right, 1);
            ctx.restore();
          }

          if (type === "bar") {
            ctx.fillStyle = labelColor;
            const meta = chart.getDatasetMeta(0);
            meta.data.forEach((bar, i) => {
              const value = Number(dataArr[i] || 0);
              const pos = bar.tooltipPosition();
              ctx.fillText(money.format(value), pos.x, pos.y - 10);
            });
          }

          ctx.restore();
        }
      };

      const porServicio = document.getElementById("ventasPorServicio");
      if (porServicio) {
        const rawLabels = data.labels_servicio || [];
        const rawValues = data.totales_servicio || [];
        const merged = rawLabels.map((label, i) => ({
          label,
          value: Number(rawValues[i] || 0)
        })).filter(item => item.value > 0);

        merged.sort((a, b) => b.value - a.value);
        const maxSlices = 7;
        const shown = [];
        let otrosValue = 0;
        merged.forEach((item, idx) => {
          if (idx < maxSlices - 1) shown.push(item);
          else otrosValue += item.value;
        });
        if (otrosValue > 0) shown.push({ label: "Otros", value: otrosValue });

        const labels = shown.map(item => item.label);
        const values = shown.map(item => item.value);

        const mix = (a, b, t) => Math.round(a + (b - a) * t);
        const base = toRgb(baseBlue);
        const white = { r: 255, g: 255, b: 255 };
        const serviceColors = values.map((_, i) => {
          if (values.length === 1) return `rgb(${base.r}, ${base.g}, ${base.b})`;
          const t = (i / (values.length - 1)) * 0.6;
          const r = mix(base.r, white.r, t);
          const g = mix(base.g, white.g, t);
          const b = mix(base.b, white.b, t);
          return `rgb(${r}, ${g}, ${b})`;
        });

        new Chart(porServicio, {
          type: "doughnut",
          data: {
            labels,
            datasets: [{
              data: values,
              backgroundColor: serviceColors,
              borderColor: "#ffffff",
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: { enabled: false }
            }
          },
          plugins: [fixedLabels]
        });
      }

      const porEstatus = document.getElementById("ventasPorEstatus");
      if (porEstatus) {
        new Chart(porEstatus, {
          type: "bar",
          data: {
            labels: ["Pagado", "Pendiente"],
            datasets: [{
              data: data.totales_estatus || [0, 0],
              backgroundColor: palette,
              borderWidth: 0,
              borderColor: "transparent"
            }]
          },
          options: {
            ...commonOptions,
            plugins: {
              legend: { display: false },
              tooltip: { enabled: false }
            }
          },
          plugins: [fixedLabels]
        });
      }
    })();
  </script>
{% endblock %}
